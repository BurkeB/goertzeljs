DTMF = (samplerate, peakFilterSensitivity, repeatMin, downsampleRate, threshold) ->
  `var key`
  self = this
  self.peakFilterSensitivity = peakFilterSensitivity
  self.downsampleRate = downsampleRate or 1
  self.samplerate = samplerate / self.downsampleRate
  self.frequencyTable =
    697:
      1209: '1'
      1336: '2'
      1477: '3'
      1633: 'A'
    770:
      1209: '4'
      1336: '5'
      1477: '6'
      1633: 'B'
    852:
      1209: '7'
      1336: '8'
      1477: '9'
      1633: 'C'
    941:
      1209: '*'
      1336: '0'
      1477: '#'
      1633: 'D'
  self.lowFrequencies = []
  for key of self.frequencyTable
    self.lowFrequencies.push parseInt(key)
  self.highFrequencies = []
  for key of self.frequencyTable[self.lowFrequencies[0]]
    self.highFrequencies.push parseInt(key)
  self.allFrequencies = self.lowFrequencies.concat(self.highFrequencies)
  self.threshold = threshold or 0
  self.repeatCounter = 0
  self.firstPreviousValue = ''
  self.goertzel = new Goertzel(self.allFrequencies, self.samplerate, self.threshold)
  self.repeatMin = repeatMin

  self.energyProfileToCharacter = (register) ->
    `var f`
    `var i`
    energies = register.energies
    # Find high frequency.
    highFrequency = 0.0
    highFrequencyEngergy = 0.0
    i = 0
    while i < self.highFrequencies.length
      f = self.highFrequencies[i]
      if energies[f] > highFrequencyEngergy and energies[f] > self.threshold
        highFrequencyEngergy = energies[f]
        highFrequency = f
      i++
    # Find low frequency.
    lowFrequency = 0.0
    lowFrequencyEnergy = 0.0
    i = 0
    while i < self.lowFrequencies.length
      f = self.lowFrequencies[i]
      if energies[f] > lowFrequencyEnergy and energies[f] > self.threshold
        lowFrequencyEnergy = energies[f]
        lowFrequency = f
      i++
    # Set up the register for garbage collection.
    register = null
    # delete register
    if self.frequencyTable[lowFrequency] != undefined
      return self.frequencyTable[lowFrequency][highFrequency] or null
    return

  self.floatBufferToInt = (floatBuffer) ->
    intBuffer = []
    i = 0
    while i < floatBuffer.length
      intBuffer.push self.goertzel.floatToIntSample(floatBuffer[i])
      i++
    intBuffer

  self.processBuffer = (buffer) ->
    `var i`
    `var lowEnergies`
    `var i`
    `var highEnergies`
    value = ''
    intSample = undefined
    register = undefined
    windowedSample = undefined
    energy = undefined
    highEnergies = []
    lowEnergies = []
    frequency = undefined
    # Downsample by choosing every Nth sample.
    i = 0
    while i < buffer.length
      intSample = buffer[i]
      windowedSample = self.goertzel.windowFunction(intSample, i, buffer.length / self.downsampleRate)
      register = self.goertzel.getEnergiesFromSample(windowedSample)
      value = self.energyProfileToCharacter(register)
      i += self.downsampleRate
    # END DOWNSAMPLE 
    # Run peak test to throw out samples with too many energy spectrum peaks or where the difference between energies is not great enough.
    highEnergies = []
    while i < self.highFrequencies.length
      f = self.highFrequencies[i]
      highEnergies.push register.energies[f]
      i++
    lowEnergies = []
    while i < self.lowFrequencies.length
      freq = self.lowFrequencies[i]
      lowEnergies.push register.energies[freq]
      i++
    badPeaks = self.goertzel.doublePeakFilter(highEnergies, lowEnergies, self.peakFilterSensitivity)
    if badPeaks == false
      if value == self.firstPreviousValue and value != undefined
        self.repeatCounter += 1
        if self.repeatCounter == self.repeatMin and typeof @onDecode == 'function'
          setTimeout @onDecode(value), 0
      else
        self.repeatCounter = 0
        self.firstPreviousValue = value
    self.goertzel.refresh()
    return

  return

# ---
# generated by js2coffee 2.0.4